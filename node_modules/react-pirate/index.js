'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');

/**
 * Wraps `setInterval`. Triggers the function each interval.
 * @param {Function} fn function to call
 * @param {number} delay in milliseconds
 * @return {void}
 */
function useInterval(fn, delay) {
  const savedCallback = useRef();

  react.useEffect(() => {
    savedCallback.current = fn;
  });

  react.useEffect(() => {
    function tick() {
      savedCallback.current();
    }
    if (delay !== null) {
      const id = setInterval(tick, delay);
      return () => clearInterval(id)
    }
  }, [delay]);
}

/**
 * Triggers the function when the initial rendering occurs. You can pass options
 * in the second parameter:
 * - hook: by default uses the `useEffect` hook, but you can replace it with
 *   `useLayoutEffect` or `useMutationEffect` if needed.
 * @param {Function} fn function to call
 * @param {object} options
 * @return {void}
 */
function useMount(fn, { hook = react.useEffect } = {}) {
  hook(() => void fn(), []);
}

/**
 * Stores a value and pass it back to the component on each render. Useful for
 * example to store a prop and compare it to the newest value.
 * @param {*} value
 * @return {*} the value stored
 */
function usePrevious(value) {
  const ref = react.useRef();
  react.useEffect(() => {
    ref.current = value;
  });
  return ref.current
}

/**
 * Wraps `setTimeout`. Triggers the function after a given delay.
 * @param {Function} fn function to call
 * @param {number} delay in milliseconds
 * @return {void}
 */
function useTimeout(fn, delay) {
  const savedCallback = useRef();

  react.useEffect(() => {
    savedCallback.current = fn;
  });

  react.useEffect(() => {
    function cb() {
      savedCallback.current();
    }
    if (delay !== null) {
      const id = setTimeout(cb, delay);
      return () => clearTimeout(id)
    }
  }, [delay]);
}

/**
 * Stores a boolean and offers methods to update it.
 * @param {boolean} initialValue
 * @return {object} a toggle object with the current value and update methods
 */
function useToggle(initialValue = true) {
  const [value, setValue] = react.useState(initialValue);

  return {
    value,
    setValue,
    toggle: () => setValue(!value),
    setTrue: () => setValue(true),
    setFalse: () => setValue(false),
  }
}

/**
 * Triggers the function when the component is unmounted. You can pass options
 * in the second parameter:
 * - hook: by default uses the `useEffect` hook, but you can replace it with
 *   `useLayoutEffect` or `useMutationEffect` if needed.
 * @param {Function} fn function to call
 * @param {object} options
 * @return {void}
 */
function useUnmount(fn, { hook = react.useEffect } = {}) {
  hook(() => fn, []);
}

/**
 * Triggers the function when the component is updated. You can pass options
 * in the second parameter:
 * - hook: by default uses the `useEffect` hook, but you can replace it with
 *   `useLayoutEffect` or `useMutationEffect` if needed.
 * @param {Function} fn
 * @param {object} options
 * @return {void}
 */
function useUpdate(fn, { hook = react.useEffect } = {}) {
  const mounting = react.useRef(true);
  hook(() => {
    if (mounting.current) {
      mounting.current = false;
    } else {
      fn();
    }
  });
}

exports.useInterval = useInterval;
exports.useMount = useMount;
exports.usePrevious = usePrevious;
exports.useTimeout = useTimeout;
exports.useToggle = useToggle;
exports.useUnmount = useUnmount;
exports.useUpdate = useUpdate;
//# sourceMappingURL=index.js.map
